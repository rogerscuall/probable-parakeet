#!/usr/bin/env python3
"""
Generate Terraform configuration from CloudWAN CSV data.

Usage:
    python generate_terraform.py <data_directory> --output <output_directory>
"""

import argparse
import csv
import os
import sys
from pathlib import Path


def load_csv(filepath: Path) -> list:
    """Load CSV file as list of dictionaries."""
    if not filepath.exists():
        return []

    with open(filepath, 'r') as f:
        return list(csv.DictReader(f))


def generate_main_tf(data_dir: Path) -> str:
    """Generate main.tf content."""
    core_network = load_csv(data_dir / 'corenetwork.csv')

    # Extract regions
    regions = set()
    asn = '64512'  # Default
    inside_cidr = '10.255.0.0/16'  # Default

    for row in core_network:
        if row.get('region'):
            regions.add(row['region'])
        if row.get('asn'):
            asn = row['asn']
        if row.get('inside_cidr_blocks'):
            inside_cidr = row['inside_cidr_blocks'].split(',')[0].strip()

    regions_list = ', '.join(f'"{r}"' for r in sorted(regions)) if regions else '"us-east-1"'

    return f'''# AWS Cloud WAN Configuration
# Generated by Network Design Platform

terraform {{
  required_version = ">= 1.0"

  required_providers {{
    aws = {{
      source  = "hashicorp/aws"
      version = ">= 5.0"
    }}
  }}
}}

# Provider configuration
provider "aws" {{
  region = var.primary_region
}}

# Variables
variable "primary_region" {{
  description = "Primary AWS region for Cloud WAN"
  type        = string
  default     = "us-east-1"
}}

variable "global_network_name" {{
  description = "Name of the global network"
  type        = string
  default     = "cloudwan-global-network"
}}

variable "core_network_name" {{
  description = "Name of the core network"
  type        = string
  default     = "cloudwan-core-network"
}}

# Global Network
resource "aws_networkmanager_global_network" "main" {{
  description = "Cloud WAN Global Network"

  tags = {{
    Name = var.global_network_name
  }}
}}

# Core Network
resource "aws_networkmanager_core_network" "main" {{
  global_network_id = aws_networkmanager_global_network.main.id
  description       = "Cloud WAN Core Network"

  tags = {{
    Name = var.core_network_name
  }}
}}

# Core Network Policy
resource "aws_networkmanager_core_network_policy_attachment" "main" {{
  core_network_id = aws_networkmanager_core_network.main.id
  policy_document = file("${{path.module}}/policy.json")
}}

# Outputs
output "global_network_id" {{
  description = "ID of the global network"
  value       = aws_networkmanager_global_network.main.id
}}

output "core_network_id" {{
  description = "ID of the core network"
  value       = aws_networkmanager_core_network.main.id
}}

output "core_network_arn" {{
  description = "ARN of the core network"
  value       = aws_networkmanager_core_network.main.arn
}}
'''


def generate_segments_tf(data_dir: Path) -> str:
    """Generate segments.tf content."""
    segments = load_csv(data_dir / 'segments.csv')

    if not segments:
        return "# No segments configured\n"

    content = '''# Segment Configuration
# Note: Segments are defined in the policy document
# This file contains segment-related resources

locals {
  segments = {
'''

    for seg in segments:
        name = seg.get('name', 'unknown')
        desc = seg.get('description', '')
        content += f'''    "{name}" = {{
      description = "{desc}"
      isolate_attachments = {str(seg.get('isolate_attachments', 'no').lower() == 'yes').lower()}
      require_attachment_acceptance = {str(seg.get('require_attachment_acceptance', 'no').lower() == 'yes').lower()}
    }}
'''

    content += '''  }
}

# Example VPC attachment (customize as needed)
# resource "aws_networkmanager_vpc_attachment" "example" {
#   core_network_id = aws_networkmanager_core_network.main.id
#   vpc_arn         = aws_vpc.example.arn
#   subnet_arns     = [aws_subnet.example.arn]
#
#   tags = {
#     segment = "production"
#   }
# }
'''

    return content


def main():
    parser = argparse.ArgumentParser(description='Generate Terraform configuration')
    parser.add_argument('data_dir', help='Directory containing CSV files')
    parser.add_argument('--output', '-o', required=True, help='Output directory')
    args = parser.parse_args()

    data_dir = Path(args.data_dir)
    output_dir = Path(args.output)

    if not data_dir.exists():
        print(f"Error: Directory not found: {data_dir}", file=sys.stderr)
        sys.exit(1)

    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)

    # Generate main.tf
    main_tf = generate_main_tf(data_dir)
    with open(output_dir / 'main.tf', 'w') as f:
        f.write(main_tf)

    # Generate segments.tf
    segments_tf = generate_segments_tf(data_dir)
    with open(output_dir / 'segments.tf', 'w') as f:
        f.write(segments_tf)

    print(f"Terraform files generated in: {output_dir}")
    print("  - main.tf")
    print("  - segments.tf")


if __name__ == '__main__':
    main()
